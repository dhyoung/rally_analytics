<!DOCTYPE HTML>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>Rally Burn Chart Prototype</title>
        
        <!-- HighCharts -->
        <script type="text/javascript" src="https://people.rallydev.com/js/jquery.min.js"></script>
        <script type="text/javascript" src="https://people.rallydev.com/js/highcharts.js"></script>
        <script type="text/javascript" src="https://people.rallydev.com/js/exporting.js"></script>
        <!-- a theme file
            <script type="text/javascript" src="../js/themes/gray.js"></script>
        -->
        
        <!-- Lumenize -->
        <script type="text/javascript" src="http://lmaccherone.github.com/Lumenize/deploy/lumenize-min.js"></script>
        
        <!-- my calculator for this chart -->
        
<script type="text/javascript">
(function() {
  var ChartTime, burnCalculator, lumenize, root, timeSeriesCalculator, utils,
    __indexOf = Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  root = this;

  if (typeof exports !== "undefined" && exports !== null) {
    lumenize = require('../lib/lumenize');
  } else {
    lumenize = require('/lumenize');
  }

  ChartTime = lumenize.ChartTime, timeSeriesCalculator = lumenize.timeSeriesCalculator;

  utils = lumenize.utils;

  burnCalculator = function(results, config) {
    /*
      Takes the "results" from a query to Rally's Analytics API (or similar MVCC-based implementation)
      and returns the series for burn charts.
    */
    var aggregationAtArray, aggregations, categories, ct, derivedFields, f, field, granularity, i, idealData, idealStep, listOfAtCTs, maxTaskEstimateTotal, name, originalPointCount, pastEnd, rangeSpec, s, series, seriesFound, seriesNames, start, timeSeriesCalculatorConfig, type, yAxis, _i, _len, _ref, _ref2, _ref3;
    if (config.granularity != null) {
      granularity = config.granularity;
    } else {
      granularity = 'day';
    }
    start = config.start;
    if (utils.type(start) === 'string') {
      start = new ChartTime(start, granularity, config.workspaceConfiguration.TimeZone);
    }
    pastEnd = new ChartTime(results[results.length - 1]._ValidFrom, granularity, config.workspaceConfiguration.TimeZone).add(1);
    rangeSpec = {
      workDays: config.workspaceConfiguration.WorkDays,
      holidays: config.holidays,
      start: start,
      pastEnd: pastEnd
    };
    if (config.upSeriesType == null) config.upSeriesType = 'Sums';
    derivedFields = [];
    if (config.upSeriesType === 'Points') {
      derivedFields.push({
        name: 'Accepted',
        f: function(row) {
          var _ref;
          if (_ref = row.ScheduleState, __indexOf.call(config.acceptedStates, _ref) >= 0) {
            return row.PlanEstimate;
          } else {
            return 0;
          }
        }
      });
    } else if (config.upSeriesType === 'Story Count') {
      derivedFields.push({
        name: 'Accepted',
        f: function(row) {
          var _ref;
          if (_ref = row.ScheduleState, __indexOf.call(config.acceptedStates, _ref) >= 0) {
            return 1;
          } else {
            return 0;
          }
        }
      });
    } else {
      console.error("Unrecognized upSeriesType: " + config.upSeriesType);
    }
    seriesNames = [];
    aggregations = [];
    _ref = config.series;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      seriesFound = true;
      switch (s) {
        case 'down':
          name = 'Task To Do (Hours)';
          f = '$sum';
          field = 'TaskRemainingTotal';
          yAxis = 0;
          type = 'column';
          break;
        case 'ideal':
          name = "Ideal (Hours)";
          f = '$sum';
          field = 'TaskEstimateTotal';
          yAxis = 0;
          type = 'line';
          break;
        case 'up':
          name = "Accepted (" + config.upSeriesType + ")";
          f = '$sum';
          field = 'Accepted';
          yAxis = 1;
          type = 'column';
          break;
        case 'scope':
          name = "Scope (" + config.upSeriesType + ")";
          if (config.upSeriesType === 'Story Count') {
            f = '$count';
          } else if (config.upSeriesType === 'Points') {
            f = '$sum';
          }
          field = 'PlanEstimate';
          yAxis = 1;
          type = 'line';
          break;
        default:
          if ((s.name != null) && (s.f != null) && (s.field != null)) {
            name = s.name;
            f = s.f;
            field = s.field;
            type = 'column';
          } else {
            seriesFound = false;
            console.error("Unrecognizable series: " + s);
          }
      }
      if (seriesFound) {
        aggregations.push({
          name: name,
          as: name,
          f: f,
          field: field,
          yAxis: yAxis,
          type: type
        });
        seriesNames.push(name);
      }
    }
    timeSeriesCalculatorConfig = {
      rangeSpec: rangeSpec,
      derivedFields: derivedFields,
      aggregations: aggregations,
      timezone: config.workspaceConfiguration.TimeZone,
      snapshotValidFromField: '_ValidFrom',
      snapshotUniqueID: 'ObjectID'
    };
    _ref2 = lumenize.timeSeriesCalculator(results, timeSeriesCalculatorConfig), listOfAtCTs = _ref2.listOfAtCTs, aggregationAtArray = _ref2.aggregationAtArray;
    series = lumenize.aggregationAtArray_To_HighChartsSeries(aggregationAtArray, aggregations);
    categories = (function() {
      var _j, _len2, _results;
      _results = [];
      for (_j = 0, _len2 = listOfAtCTs.length; _j < _len2; _j++) {
        ct = listOfAtCTs[_j];
        _results.push("" + (ct.toString()));
      }
      return _results;
    })();
    originalPointCount = categories.length;
    i = 0;
    while (series[i].name.indexOf("Ideal") < 0) {
      i++;
    }
    idealData = series[i].data;
    maxTaskEstimateTotal = lumenize.functions.$max(idealData);
    idealStep = maxTaskEstimateTotal / (originalPointCount - 1);
    for (i = 0, _ref3 = originalPointCount - 2; 0 <= _ref3 ? i <= _ref3 : i >= _ref3; 0 <= _ref3 ? i++ : i--) {
      idealData[i] = (originalPointCount - 1 - i) * idealStep;
    }
    idealData[originalPointCount - 1] = 0;
    return {
      categories: categories,
      series: series
    };
  };

  root.burnCalculator = burnCalculator;

}).call(this);

</script> 
                
        <script type="text/javascript">
        
            var lumenize = require('/lumenize');
            lumenize.ChartTime.setTZPath('anything');
            
            $(document).ready(function() {
                            
                // Let's say you have this data. I've put it in this CSV-style format for easy entry and comprehension.
                resultsCSVStyle = [
                    ["ObjectID", "_ValidFrom",           "ScheduleState"  , "PlanEstimate", "TaskRemainingTotal", "TaskEstimateTotal"],
                                                                        
                    [1,          "2010-10-10T15:00:00Z", "Ready to pull", 5            , 15                     , 15],  // Shouldn't show up, 2010 before start
                    
                    [1,          "2011-01-02T13:00:00Z", "Ready to pull", 5            , 15                     , 15],  // !TODO: Should get the same results even without this line
                    [1,          "2011-01-02T15:10:00Z", "In progress"  , 5            , 20                     , 15],  // Testing it starting at one state and switching later to another
                    [2,          "2011-01-02T15:00:00Z", "Ready to pull", 3            , 5                      , 5],                
                    [3,          "2011-01-02T15:00:00Z", "Ready to pull", 5            , 12                     , 12], 
                    
                    [2,          "2011-01-03T15:00:00Z", "In progress"  , 3            , 5                      , 5], 
                    [3,          "2011-01-03T15:00:00Z", "Ready to pull", 5            , 12                     , 12], 
                    [4,          "2011-01-03T15:00:00Z", "Ready to pull", 5            , 15                     , 15], 
                    [1,          "2011-01-03T15:10:00Z", "In progress"  , 5            , 12                     , 15],  // Testing later change
                    
                    [1,          "2011-01-04T15:00:00Z", "Accepted"     , 5            , 0                      , 15], 
                    [2,          "2011-01-04T15:00:00Z", "In test"      , 3            , 1                      , 5], 
                    [3,          "2011-01-04T15:00:00Z", "In progress"  , 5            , 10                     , 12], 
                    [4,          "2011-01-04T15:00:00Z", "Ready to pull", 5            , 15                     , 15], 
                    [5,          "2011-01-04T15:00:00Z", "Ready to pull", 2            , 4                      , 4], 
                    
                    [3,          "2011-01-05T15:00:00Z", "In test"      , 5            , 5                      , 12],
                    
                    [1,          "2011-01-06T15:00:00Z", "Released"     , 5            , 0                      , 15], 
                    [2,          "2011-01-06T15:00:00Z", "Accepted"     , 3            , 0                      , 5], 
                    [4,          "2011-01-06T15:00:00Z", "In progress"  , 5            , 7                      , 15], 
                    [5,          "2011-01-06T15:00:00Z", "Ready to pull", 2            , 4                      , 4], 
                    
                    [1,          "2011-01-07T15:00:00Z", "Released"     , 5            , 0                      , 15], 
                    [2,          "2011-01-07T15:00:00Z", "Released"     , 3            , 0                      , 5], 
                    [3,          "2011-01-07T15:00:00Z", "Accepted"     , 5            , 0                      , 12], 
                    [4,          "2011-01-07T15:00:00Z", "In test"      , 5            , 3                      , 15], 
                    [5,          "2011-01-07T15:00:00Z", "In progress"  , 2            , 4                      , 4]
                ];
                
                // The CSV-style table is not what it would look like from the Rally Analytics API so let's fix that.
                var results = lumenize.csvStyleArray_To_ArrayOfMaps(resultsCSVStyle);
                
                // Replace above code with call to LookbackAPI
                // For PI/Story burn chart, {_ItemHiearchy: 123456L} where 123456L is the ObjectID of the PI or Story
                
                var workspaceConfiguration = {  // Need to grab from Rally for this user
                  DateFormat: 'MM/dd/yyyy',
                  DateTimeFormat: 'MM/dd/yyyy hh:mm:ss a',
                  IterationEstimateUnitName: 'Points',  // !TODO: Should we use this?
                  ReleaseEstimateUnitName: 'Points',
                  TaskUnitName: 'Hours',
                  TimeTrackerEnabled: true,
                  TimeZone: 'America/Denver',
                  WorkDays: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday' // They work on Sundays
                };
                
                var config = {
                  workspaceConfiguration: workspaceConfiguration,
                  upSeriesType: 'Points', // 'Points' or 'Story Count'
                  series: [
                    'down',
                    'up',
                    'projectionToCurrentScope',
                    'projectionToProjectedScope',
                    'ideal',
                    'scope'
                  ],
                  acceptedStates: ['Accepted', 'Released'],
                  start: "2011-01-02T13:00:00Z",  // Calculated either by inspecting results or via configuration. pastEnd is automatically the last date in results
                  holidays: [
                    {month: 12, day: 25}, // Notice how the year can be omitted
                    {year: 2011, month: 11, day: 26},
                    {year: 2011, month: 1, day: 5}  // Made up holiday to demo holiday knockout
                  ]
                };
                                
                var tscResults = burnCalculator(results, config);
                
                var categories = tscResults.categories;
                var series = tscResults.series;
                
                chart = new Highcharts.Chart({
                    chart: {
                        renderTo: 'container',
                        defaultSeriesType: 'column'
                    },
                    credits: {
                        enabled: false
                    },
                    title: {
                        text: 'Burn Chart'
                    },
                    subtitle: {
                        text: ''
                    },
                    xAxis: {
                        categories: categories,
                        tickmarkPlacement: 'on',
                        // tickInterval: 2, // set as a function of the length of categories
                        title: {
                            enabled: false
                        }
                    },
                    yAxis: [
                        {
                            title: {
                                text: 'Hours'
                            },
                            labels: {
                                formatter: function() {
                                    return this.value / 1;
                                }
                            },
                            min: 0
                        },
                        {
                            title: {
                                text: config.upSeriesType
                            },
                            opposite: true,
                            labels: {
                                formatter: function() {
                                    return this.value / 1;
                                }
                            },
                            min: 0
                        }                        
                    ],
                    tooltip: {
                        formatter: function() {
                            return ''+ this.x + '<br />' + this.series.name + ': ' + this.y;
                        }
                    },
                    plotOptions: {
                        column: {
                            stacking: null,
                            lineColor: '#666666',
                            lineWidth: 1,
                            marker: {
                                lineWidth: 1,
                                lineColor: '#666666'
                            }
                        },
/*
                        series: {
                            allowPointSelect: true,
                            point: {
                                events: {
                                    select: function(event) {
                                        // Use this to highlight the rows in a table
                                        alert('ObjectIDs: ' +
                                            JSON.stringify(cfdCalculation.drillDownObjectIDs[this.series.name][this.x]));
                                    },
                                    unselect: function(event) {
                                        alert('Unselect rows')
                                    }
                                }
                            }
                        }
*/
                    },
                    series: series
                });
                      
                                  
                
            });
                
        </script>
        
    </head>
    <body>
        
        <!-- 3. Add the container -->
        <div id="container" style="width: 75%; height: 75%; margin: 0 auto"></div>
        
    </body>
</html>
